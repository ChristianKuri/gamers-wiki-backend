import { z } from 'zod';

import { ARTICLE_PLAN_CONSTRAINTS } from './config';

// Re-export for consumers that import from article-plan
export { ARTICLE_PLAN_CONSTRAINTS } from './config';

// ============================================================================
// Category Slug Schema
// ============================================================================

/** Canonical category slugs (plural form) */
export type ArticleCategorySlug = 'news' | 'reviews' | 'guides' | 'lists';

/** Input that also accepts alias forms for backwards compatibility */
export type ArticleCategorySlugInput = ArticleCategorySlug | 'review' | 'guide' | 'list';

/**
 * Schema for category slugs that accepts canonical and alias forms.
 *
 * NOTE: See gotchas.md "Zod Transforms Don't Work with AI SDK's generateText"
 * for why this doesn't use .transform(). Use normalizeArticleCategorySlug() after parsing.
 */
export const ArticleCategorySlugSchema = z.enum([
  'news',
  'reviews',
  'guides',
  'lists',
  // Backwards-compatible aliases (some prompts/models may still output these)
  'review',
  'guide',
  'list',
]);

/**
 * Normalizes category slug aliases to canonical form.
 * Call this AFTER parsing with ArticleCategorySlugSchema.
 *
 * @example
 * const parsed = ArticleCategorySlugSchema.parse(input);
 * const normalized = normalizeArticleCategorySlug(parsed);
 */
export function normalizeArticleCategorySlug(value: ArticleCategorySlugInput): ArticleCategorySlug {
  if (value === 'review') return 'reviews';
  if (value === 'guide') return 'guides';
  if (value === 'list') return 'lists';
  return value;
}

// ============================================================================
// Section Plan Schema
// ============================================================================

export const ArticleSectionPlanSchema = z.object({
  headline: z.string().min(1),
  goal: z.string().min(1),
  researchQueries: z
    .array(z.string().min(1))
    .min(ARTICLE_PLAN_CONSTRAINTS.MIN_RESEARCH_QUERIES_PER_SECTION)
    .max(ARTICLE_PLAN_CONSTRAINTS.MAX_RESEARCH_QUERIES_PER_SECTION),
  /**
   * Specific elements this section MUST cover (REQUIRED).
   * Assigned by the Editor from the global requiredElements list.
   * Each element should appear in exactly one section's mustCover.
   * The Specialist uses this for targeted, per-section accountability.
   *
   * Making this required ensures the LLM always outputs it via schema enforcement.
   */
  mustCover: z
    .array(z.string().min(1))
    .min(1, 'Each section must have at least one element to cover'),
});

export type ArticleSectionPlan = z.infer<typeof ArticleSectionPlanSchema>;

// ============================================================================
// Article Metadata Schema (generated by Metadata Agent after article is written)
// ============================================================================

/**
 * Schema for article metadata generated by the Metadata Agent.
 * This runs AFTER the Specialist writes the article, so it can use the actual
 * article content to generate more accurate SEO-optimized metadata.
 */
export const ArticleMetadataSchema = z.object({
  title: z
    .string()
    .min(ARTICLE_PLAN_CONSTRAINTS.TITLE_MIN_LENGTH, `Title too short (minimum ${ARTICLE_PLAN_CONSTRAINTS.TITLE_MIN_LENGTH} characters)`)
    .max(ARTICLE_PLAN_CONSTRAINTS.TITLE_MAX_LENGTH, `Title too long (maximum ${ARTICLE_PLAN_CONSTRAINTS.TITLE_MAX_LENGTH} characters)`),
  excerpt: z
    .string()
    .min(ARTICLE_PLAN_CONSTRAINTS.EXCERPT_MIN_LENGTH)
    .max(ARTICLE_PLAN_CONSTRAINTS.EXCERPT_MAX_LENGTH),
  description: z
    .string()
    .min(ARTICLE_PLAN_CONSTRAINTS.DESCRIPTION_MIN_LENGTH)
    .max(ARTICLE_PLAN_CONSTRAINTS.DESCRIPTION_MAX_LENGTH),
  tags: z
    .array(
      z.string()
        .min(1)
        .regex(/\S/, 'Tag cannot be whitespace only')
        .max(ARTICLE_PLAN_CONSTRAINTS.TAG_MAX_LENGTH, `Tag too long (maximum ${ARTICLE_PLAN_CONSTRAINTS.TAG_MAX_LENGTH} characters)`)
    )
    .min(ARTICLE_PLAN_CONSTRAINTS.MIN_TAGS, `At least ${ARTICLE_PLAN_CONSTRAINTS.MIN_TAGS} tag is required`)
    .max(ARTICLE_PLAN_CONSTRAINTS.MAX_TAGS, `Maximum ${ARTICLE_PLAN_CONSTRAINTS.MAX_TAGS} tags allowed`),
});

/**
 * Type for article metadata (output from Metadata Agent).
 */
export type ArticleMetadata = z.infer<typeof ArticleMetadataSchema>;

// ============================================================================
// Article Plan Schema
// ============================================================================

/**
 * Default safety settings for article plans.
 * Applied by Editor agent when AI omits the safety field.
 *
 * NOTE: This is intentionally an object (not a single boolean) to allow future
 * extensibility. Planned additions include:
 * - noSpoilers: Avoid plot spoilers without warning
 * - noPriceGuesses: Avoid speculating on current prices (historical prices are fine)
 * - noUnverifiedClaims: Flag statements that can't be backed by sources
 */
export const DEFAULT_ARTICLE_SAFETY = {
  noScoresUnlessReview: true,
} as const;

/**
 * Article plan schema for AI SDK's generateText.
 * 
 * NOTE: This schema focuses on content structure planning only.
 * Metadata (title, excerpt, description, tags) is generated separately by
 * the Metadata Agent after the article is written.
 *
 * NOTE: See gotchas.md "Zod Transforms Don't Work with AI SDK's generateText"
 * - categorySlug accepts aliases; Editor normalizes after parsing
 * - safety is optional; Editor applies DEFAULT_ARTICLE_SAFETY if omitted
 * - gameName/gameSlug come from context, not AI output
 */
export const ArticlePlanSchema = z.object({
  categorySlug: ArticleCategorySlugSchema,
  sections: z
    .array(ArticleSectionPlanSchema)
    .min(ARTICLE_PLAN_CONSTRAINTS.MIN_SECTIONS)
    .max(ARTICLE_PLAN_CONSTRAINTS.MAX_SECTIONS),
  safety: z
    .object({
      noScoresUnlessReview: z.boolean(),
    })
    .optional(),
  /**
   * Key elements that MUST be covered in the article.
   * Derived from Scout research, used by Specialist to ensure comprehensive coverage.
   * Examples: core abilities, key locations, essential items, critical quests.
   */
  requiredElements: z
    .array(z.string().min(1))
    .min(ARTICLE_PLAN_CONSTRAINTS.MIN_REQUIRED_ELEMENTS)
    .max(ARTICLE_PLAN_CONSTRAINTS.MAX_REQUIRED_ELEMENTS)
    .optional(),
});

/**
 * Article plan type with normalized categorySlug (canonical form).
 * This is the type used throughout the system after Editor normalizes the plan.
 * 
 * NOTE: Metadata fields (title, excerpt, description, tags) are NOT part of the plan.
 * They are generated by the Metadata Agent after the article is written.
 */
export interface ArticlePlan {
  /** The game this article is about (from context, not AI output) */
  readonly gameName: string;
  /** URL-friendly slug for the game (from context, optional) */
  readonly gameSlug?: string;
  readonly categorySlug: ArticleCategorySlug;
  readonly sections: readonly ArticleSectionPlan[];
  /**
   * Safety constraints for article generation.
   * Structured as an object for future extensibility (see DEFAULT_ARTICLE_SAFETY).
   */
  readonly safety: {
    /** If true, avoid numerical scores/ratings unless this is a review article */
    readonly noScoresUnlessReview: boolean;
  };
  /**
   * Key elements that MUST be covered in the article.
   * Derived from Scout research by the Editor agent.
   * Used by Specialist to ensure comprehensive coverage and by validation
   * to warn about missing elements.
   *
   * Examples:
   * - For guides: core abilities, key locations, essential items, critical quests
   * - For reviews: main strengths, main weaknesses, key mechanics
   * - For news: who, what, when, where, why
   * - For lists: the items being ranked/listed
   */
  readonly requiredElements?: readonly string[];
}
